// ... (previous imports and user code remain above)

// Uncomment this constant now that we are using it
const (
	// usersCollection = "users"
	dropsCollection = "drops"
)

// =================================================================
// DropRepository Implementation
// These methods fulfill the interface defined in drop_service.go (not shown here)
// =================================================================

// CreateDrop saves a new listing to the "drops" collection.
func (f *FirestoreClient) CreateDrop(ctx context.Context, drop *domain.Drop) error {
	// Similar to users, we use .Create to ensure no ID collisions.
	// The drop.ID should have been generated by the service layer before calling this.
	_, err := f.client.Collection(dropsCollection).Doc(drop.ID).Create(ctx, drop)
	if err != nil {
		return fmt.Errorf("firestore create drop error: %w", err)
	}
	return nil
}

// GetDropByID fetches a single drop, needed for rendering the product details page.
func (f *FirestoreClient) GetDropByID(ctx context.Context, dropID string) (*domain.Drop, error) {
	docRef := f.client.Collection(dropsCollection).Doc(dropID)
	docSnap, err := docRef.Get(ctx)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			// We use a generic domain error here so the service layer doesn't know about gRPC codes
			return nil, fmt.Errorf("drop not found: %w", service.ErrDropNotFound)
		}
		return nil, fmt.Errorf("firestore get drop error: %w", err)
	}

	var drop domain.Drop
	if err := docSnap.DataTo(&drop); err != nil {
		return nil, fmt.Errorf("failed to map data to drop struct: %w", err)
	}
	return &drop, nil
}

// ListAvailableDrops is used for the main shop front page.
// It needs to perform a filtered QUERY, not just get a single doc.
func (f *FirestoreClient) ListAvailableDrops(ctx context.Context, limit int) ([]domain.Drop, error) {
	// 1. Build the query
	// "Select * from drops where status == 'available' order by created_at desc limit X"
	query := f.client.Collection(dropsCollection).
		Where("status", "==", domain.StatusAvailable).
		OrderBy("created_at", firestore.Desc).
		Limit(limit)

	// 2. Execute query to get an iterator
	iter := query.Documents(ctx)
	defer iter.Stop() // Clean up resources

	var drops []domain.Drop

	// 3. Loop through results
	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break // Finished loop
		}
		if err != nil {
			return nil, fmt.Errorf("firestore query iteration error: %w", err)
		}

		var drop domain.Drop
		// Decode the raw document data into the struct
		if err := doc.DataTo(&drop); err != nil {
			// Log error here in reality, but don't fail the whole request for one bad doc
			continue 
		}
		drops = append(drops, drop)
	}

	return drops, nil
}

// UpdateDropStatus is critical for the checkout flow.
// When a user clicks "Checkout", we must set status to "pending" immediately
// to prevent double-buying.
func (f *FirestoreClient) UpdateDropStatus(ctx context.Context, dropID string, newStatus domain.DropStatus) error {
	docRef := f.client.Collection(dropsCollection).Doc(dropID)

	// Atomic partial update
	updates := []firestore.Update{
		{Path: "status", Value: newStatus},
		{Path: "updated_at", Value: time.Now().UTC()},
	}

	// Add a precondition: We might want to ensure it's currently "available" before marking it "pending".
	// This is an advanced Firestore feature called Preconditions to prevent race conditions.
	// For simplicity here, we'll just do a standard update.
	_, err := docRef.Update(ctx, updates)
	if err != nil {
		if status.Code(err) == codes.NotFound {
			return fmt.Errorf("drop not found during update: %w", service.ErrDropNotFound)
		}
		return fmt.Errorf("firestore update drop status error: %w", err)
	}
	return nil
}
